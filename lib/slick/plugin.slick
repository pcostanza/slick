(package main)

(import	"errors"
				"fmt"
				"github.com/exascience/slick/lib"
				"github.com/exascience/slick/list"
				"github.com/exascience/slick/compiler")

(var (sampersand := (lib:Intern "" "&"))
		 (sappend := (lib:Intern "github.com/exascience/slick/list" "Append"))
		 (scar := (lib:Intern "" "Car"))
		 (scdr := (lib:Intern "" "Cdr"))
		 (scons := (lib:Intern "github.com/exascience/slick/list" "Cons"))
     (sintern := (lib:Intern "github.com/exascience/slick/lib" "Intern"))
		 (slist := (lib:Intern "github.com/exascience/slick/list" "List"))
		 (smakeStruct := (lib:Intern "" "make-struct"))
		 (spair := (lib:Intern "github.com/exascience/slick/list" "Pair"))
  	 (squasiquote := (lib:Intern "" "quasiquote"))
		 (squote := (lib:Intern "" "quote"))	
		 (sunquote := (lib:Intern "" "unquote"))
		 (sunquoteSplicing := (lib:Intern "" "unquote-splicing")))

(func Quote ((form (* list:Pair)) (_ compiler:Environment)) ((newForm (interface)) (err error))
			(if (|| (== (list:Cdr form) (list:Nil))
					 (!= (list:Cddr form) (list:Nil)))
					(return (values nil (fmt:Errorf "Invalid quote form %v" form))))
			(type-switch value (list:Cadr form)
									 (((* lib:Symbol))
										(return (values (list:List sintern (slot value Package) (slot value Identifier)) nil)))
									 (((* list:Pair))
										(if (== value nil)
												(return (values value nil)))
										(return (values (list:List sampersand
																							 (list:List smakeStruct spair
																							 						scar (list:List squote (slot value Car))
																													scdr (list:List squote (slot value Cdr))))
																		nil)))
									 (default (return (values value nil)))))

(func Unquote ((_ (* list:Pair)) (_ compiler:Environment)) ((_ (interface)) (err error))
			(return (values nil (errors:New "Invalid use of unquote outside of quasiquote."))))

(func UnquoteSplicing ((_ (* list:Pair)) (_ compiler:Environment)) ((_ (interface)) (err error))
			(return (values nil (errors:New "Invalid use of unquote-splicing outside of quasiquote."))))

(func Quasiquote ((form (* list:Pair)) (_ compiler:Environment)) ((newForm (interface)) (err error))
			(:= interestingToQuasiquote
			    (func ((x (interface)) (marker (* lib:Symbol))) ((_ bool))
						(:= (lst ok) (assert x (* list:Pair)))
						(if (== lst nil)
								(return false))
						(return (&& ok (== (slot lst Car) marker)))))
			(:= finalizeQuasiquote
			    (func ((mode (* lib:Symbol)) (arg (interface))) ((form (interface)) (err error))
			      (switch true
              (((== mode squote))
							 (return (values (list:List squote arg) nil)))
							(((== mode sunquote))
							 (if* (:= (lst ok) (assert arg (* list:Pair))) (&& ok (== (slot lst Cdr) (list:Nil)))
							   (return (values (slot lst Car) nil))
								 (return (values nil (errors:New "unquote in invalid context")))))
						  (((== mode sunquoteSplicing))
							 (return (values nil (errors:New "unquote-splicing in invalid context"))))
						  (default (return (values (list:Cons mode arg) nil))))))
			(var (descendQuasiquote :type (func ((x (interface)) (level int)
					 		                            (ret (func ((mode (* lib:Symbol)) (x (interface))) ((form (interface)) (err error)))))
								                         ((form (interface)) (err error)))))
			(:= descendQuasiquotePair
			    (func ((x (interface)) (level int)
			           (ret (func ((mode (* lib:Symbol)) (x (interface))) ((form (interface)) (err error)))))
							  ((form (interface)) (err error))
					  (return (descendQuasiquote (list:Car x) level
						          (func ((carMode (* lib:Symbol)) (carArg (interface)))
											      ((form (interface)) (err error))
											  (return (descendQuasiquote (list:Cdr x) level
												          (func ((cdrMode (* lib:Symbol)) (cdrArg (interface)))
												        	      ((form (interface)) (err error))
								        			      (switch true
			        									      (((&& (== carMode squote) (== cdrMode squote)))
							        						     (return (ret squote x)))
											        		    (((== carMode sunquote))
																			 (:= (finalizedCdr err) (finalizeQuasiquote cdrMode cdrArg))
																			 (if (!= err nil)
																					 (return (values nil err)))
													             (if* (:= (lst ok) (assert carArg (* list:Pair))) (&& ok (== (slot lst Cdr) (list:Nil)))
						        							       (return (ret scons (list:List (list:Car carArg) finalizedCdr)))
										        				     (return (ret sappend (list:List (list:Cons slist carArg) finalizedCdr)))))
								        				      (((== carMode sunquoteSplicing))
						        							     (if* (:= (lst ok) (assert carArg (* list:Pair)))
										        			          (&& (== cdrMode squote) (== cdrArg (list:Nil))
							        									        ok (== (list:Cdr carArg) (list:Nil)))
																				 (return (ret sunquote carArg))
																				 (begin
																					(:= (finalizedCdr err) (finalizeQuasiquote cdrMode cdrArg))
																					(if (!= err nil)
																							(return (values nil err)))
  					        								    	 (return (ret sappend (list:Append lst (list:List finalizedCdr)))))))
																			 (default
																				 (:= (finalizedCar err) (finalizeQuasiquote carMode carArg))
																				 (if (!= err nil)
																						 (return (values nil err)))
																				 (:= (finalizedCdr err) (finalizeQuasiquote cdrMode cdrArg))
																				 (if (!= err nil)
																						 (return (values nil err)))
								        					      (return (ret scons (list:List finalizedCar finalizedCdr)))))))))))))
			(= descendQuasiquote
			    (func ((x (interface)) (level int)
					 		   (ret (func ((mode (* lib:Symbol)) (x (interface))) ((form (interface)) (err error)))))
								((form (interface)) (err error))
						(if* (:= (_ ok) (assert x (* list:Pair))) (! ok)
						   (return (ret squote x)))
				    (switch true
						  (((interestingToQuasiquote x squasiquote))
							 (return (descendQuasiquotePair x (+ level 1) ret)))
							(((interestingToQuasiquote x sunquote))
							 (if (== level 0)
							   (return (ret sunquote (list:Cdr x)))
								 (return (descendQuasiquotePair x (- level 1) ret))))
						  (((interestingToQuasiquote x sunquoteSplicing))
							 (if (== level 0)
							    (return (ret sunquoteSplicing (list:Cdr x)))
									(return (descendQuasiquotePair x (- level 1) ret))))
							(default (return (descendQuasiquotePair x level ret))))))
			(if* (:= (_ ok) (assert (list:Cdr form) (* list:Pair)))
			     (&& ok (== (list:Cddr form) (list:Nil)))
			  (return (descendQuasiquote (list:Cadr form) 0 finalizeQuasiquote))
				(return (values form nil))))
